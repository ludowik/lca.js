<!doctype html>
<html>

	<head>
	  <title>lca.js</title>
	  <meta charset="utf-8"/>
	  <meta name="viewport" content="width=device-width, initial-scale=1"/>
	</head>

	<body>
		<p>[ On affichera ici le résultat de la détection du support WebGL ]</p>
		<canvas>Il semblerait que votre navigateur ne supporte pas le canevas HTML5</canvas>
	</body>
	
	<script type="x-shader/x-vertex" id="vertex-shader">
		#version 100
		#pragma language glsl3
		precision highp float;
		attribute vec3 vPosition;
		void main() {
			gl_Position = vec4(vPosition, 1.0);
			gl_PointSize = 32.0;
		}
	</script>
	
	<script type="x-shader/x-fragment" id="fragment-shader">
		#version 100
		#pragma language glsl3
		precision highp float;
		void main() {
			vec2 fragmentPosition = 2.0 * gl_PointCoord - 1.0;
			
			float distance = length(fragmentPosition);
			float distanceSqrd = distance * distance;
			
			gl_FragColor = vec4(
				0.2/distanceSqrd,
				0.1/distanceSqrd,
				0.0,
				1.0);
		}
	</script>
	
	<script>
		let gl;
		function detectWebGLContext() {
			let paragraph = document.querySelector("p");
		
			let canvas = document.querySelector("canvas");
			gl = canvas.getContext("webgl");

			if (gl && gl instanceof WebGLRenderingContext) {
			  paragraph.innerHTML = "Félicitations, votre navigateur supporte WebGL.";
			  return gl;
			}
			
			paragraph.innerHTML = "Échec du contexte WebGL. " + "Votre navigateur peut ne pas supporter WebGL.";
		}
		
		class Shader {
			constructor() {
				let source = document.querySelector("#vertex-shader").innerHTML;
				this.vertexShader = gl.createShader(gl.VERTEX_SHADER);
				gl.shaderSource(this.vertexShader, source);
				gl.compileShader(this.vertexShader);
				
				if (!gl.getShaderParameter(this.vertexShader, gl.COMPILE_STATUS)) {
					let compileErrLog = gl.getShaderInfoLog(this.vertexShader);
					document.querySelector("p").innerHTML = "La compilation du vertex shader a échoué." + "Journal d'erreur : " + compileErrLog;
					return;
				}
				
				source = document.querySelector("#fragment-shader").innerHTML			
				this.fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
				gl.shaderSource(this.fragmentShader, source);
				gl.compileShader(this.fragmentShader);
				
				if (!gl.getShaderParameter(this.fragmentShader, gl.COMPILE_STATUS)) {
					let compileErrLog = gl.getShaderInfoLog(this.fragmentShader);
					document.querySelector("p").innerHTML = "La compilation du fragment shader a échoué." + "Journal d'erreur : " + compileErrLog;
					return;
				}
				
				this.program = gl.createProgram();
				
				gl.attachShader(this., this.vertexShader);
				gl.attachShader(this.program, this.fragmentShader);
				
				gl.linkProgram(this.program);
				
				gl.detachShader(this.program, this.vertexShader);
				gl.detachShader(this.program, this.fragmentShader);
				
				gl.deleteShader(this.vertexShader);
				gl.deleteShader(this.fragmentShader);
				
				if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
					let linkErrLog = gl.getProgramInfoLog(this.program);
					this.destructor();
					document.querySelector("p").innerHTML = "La liaison du programme a échoué." + "Journal d'erreur : " + linkErrLog;
					return;
				}
			}
			
			destructor() {
				document.querySelector("p").innerHTML = "fini";
				if (this.program)
				  gl.deleteProgram(this.program);
			}
		}
		
		function initShaders() {
			return new Shader();
		}
		
		let buffer;
		function initializeAttributes(x=0, y=0, z=0) {
			buffer = gl.createBuffer();
			gl.enableVertexAttribArray(0);
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([x, y, z]), gl.DYNAMIC_DRAW);
			gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
		}
		
		function point(x, y, z=0) {
			initializeAttributes(x, y, z);
			gl.drawArrays(gl.POINTS, 0, 1);
		}

		// https://developer.mozilla.org/fr/docs/Web/API/WebGL_API/Tutorial/Adding_2D_content_to_a_WebGL_context
		gl = detectWebGLContext();
		if (gl) {
			//gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
			//gl.clearColor(0.0, 0.5, 0.0, 1.0);
			//gl.clear(gl.COLOR_BUFFER_BIT);
			gl.clearColor(0.0, 0.0, 0.0, 1.0);  // effacement en noir, complètement opaque
			gl.clearDepth(1.0);                 // tout effacer
			gl.enable(gl.DEPTH_TEST);           // activer le test de profondeur
			gl.depthFunc(gl.LEQUAL);            // les choses proches cachent les choses lointaines

			// Effacer le canevas avant que nous ne commencions à dessiner dessus.

			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
			
			let shader = initShaders()

			gl.useProgram(shader.program);
			
			point(0.0, 0.5);
			point(0.5, -0.5);
			
			gl.useProgram(null);
			if (buffer)
			  gl.deleteBuffer(buffer);
			
			//delete shader;
			shader.destructor()
		}
	</script>
	
</html>